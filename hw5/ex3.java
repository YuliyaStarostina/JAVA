// Реализовать алгоритм пирамидальной сортировки (HeapSort) java с описанием каждого этапа
// 1. Создание кучи (Heap) из массива: 

// - Из массива строится двоичное дерево. 
// - Каждый родительский элемент должен быть больше своих дочерних элементов. 
// - Для этого необходимо просмотреть все элементы массива и выполнить соответствующие перестановки.

// 2. Сортировка кучи:

// - Берем корневой элемент кучи, который является максимальным, и отправляем его в конец массива. 
// - Затем мы меняем последний элемент и корневой элемент местами и уменьшаем размер кучи на 1. 
// - После этого делаем проверку и перестройку вершин, если необходимо. 
// - Куча должна соответствовать правилам двоичного дерева. 
// - После перестройки идем опять к корневому элементу и повторяем вышеуказанные шаги до тех пор, пока размер кучи не станет равным 1.

// 3. Результат:

// - Массив отсортирован по неубыванию. 


package hw5;

public class ex3 {
    public static void sort(int arr[]) {
        int n = arr.length;
 
        // Построение кучи
        for (int i = n / 2 - 1; i >= 0; i--)
            heapify(arr, n, i);
 
        // Один за другим извлекаем элементы из кучи
        for (int i = n - 1; i > 0; i--) {
            // Перемещаем текущий корень в конец
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
 
            // вызываем процедуру heapify на уменьшенной куче
            heapify(arr, i, 0);
        }
    }
 
    // Функция для построения кучи из поддерева с корневым узлом i, который является индексом в arr[]. n - размер кучи
    static void heapify(int arr[], int n, int i) {
        int largest = i; //инициализируем наибольший элемент как корень
        int l = 2 * i + 1; //левый = 2*i + 1
        int r = 2 * i + 2; //правый = 2*i + 2
 
        // Если левый дочерний элемен лейтарше корня
        if (l < n && arr[l] > arr[largest])
            largest = l;
 
        // Если правый дочерний элемент больше, чем самый большой элемент на данный момент
        if (r < n && arr[r] > arr[largest])
            largest = r;
 
        // Если самый большой элемент не корень
        if (largest != i) {
            int swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;
 
            // Рекурсивно вызываем heapify для получения правильной структуры кучи после замены
            heapify(arr, n, largest);
        }
    }
    
    // Пример работы алгоритма:
    public static void main(String args[]) {
        int arr[] = {12, 11, 13, 5, 6, 7};
 
        sort(arr);
 
        System.out.println("Отсортированный массив: ");
        for (int i = 0; i < arr.length; ++i)
            System.out.print(arr[i] + " ");
    }
}
    

